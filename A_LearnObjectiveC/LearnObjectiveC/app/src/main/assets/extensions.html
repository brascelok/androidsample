<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>

	

<p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension).</p>

<p>The methods declared by a class extension are implemented in the implementation block for the original class, so you can&apos;t, for example, declare a class extension on a framework class, such as a Cocoa or Cocoa Touch class like NSString..</p>

<p>Extensions are actually categories without the category name. It&apos;s often referred as<strong>anonymous categories</strong>.</p>

<p>The syntax to declare a extension uses the @interface keyword, just like a standard Objective-C class description, but does not indicate any inheritance from a subclass. Instead, it just adds parentheses, as shown below</p><pre>@interface ClassName ()

@end</pre>

<h2>Characteristics of extensions</h2>

<ul>
	<li>

		<p>An extension cannot be declared for any class, only for the classes that we have original implementation of source code.</p>
	</li>
	<li>

		<p>An extension is adding private methods and private variables that are only specific to the class.</p>
	</li>
	<li>

		<p>Any method or variable declared inside the extensions is not accessible even to the inherited classes.</p>
	</li>
</ul>

<h2>Extensions Example</h2>

<p>Let&apos;s create a class SampleClass that has an extension. In the extension, let&apos;s have a private variable internalID.</p>

<p>Then, let&apos;s have a method getExternalID that returns the externalID after processing the internalID.</p>

<p>The example is shown below and this wont work on online compiler.</p><pre>#import &lt;Foundation/Foundation.h&gt;

@interface SampleClass : NSObject
{
&nbsp; &nbsp; NSString *name;
}

- (void)setInternalID;
- (NSString *)getExternalID;

@end


@interface SampleClass()
{
&nbsp; &nbsp; NSString *internalID;
}

@end

@implementation SampleClass

- (void)setInternalID{
&nbsp; &nbsp; internalID = [NSString stringWithFormat: 
&nbsp; &nbsp; @&quot;UNIQUEINTERNALKEY%dUNIQUEINTERNALKEY&quot;,arc4random()%100];
}

- (NSString *)getExternalID{
&nbsp; &nbsp; return [internalID stringByReplacingOccurrencesOfString: 
&nbsp; &nbsp; @&quot;UNIQUEINTERNALKEY&quot; withString:@&quot;&quot;];
}

@end

int main(int argc, const char * argv[])
{
&nbsp; &nbsp; NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
&nbsp; &nbsp; SampleClass *sampleClass = [[SampleClass alloc]init];
&nbsp; &nbsp; [sampleClass setInternalID];
&nbsp; &nbsp; NSLog(@&quot;ExternalID: %@&quot;,[sampleClass getExternalID]); &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; [pool drain];
&nbsp; &nbsp; return 0;
}</pre>

<p>Now when we compile and run the program, we will get the following result.</p><pre>2013-09-22 21:18:31.754 Extensions[331:303] ExternalID: 51</pre>

<p>In the above example, we can see that the internalID is not returned directly. We here remove the UNIQUEINTERNALKEY and only make the remaining value available to the method getExternalID.</p>

<p>The above example just uses a string operation, but it can have many features like encryption/decryption and so on.</p>

	
</body>
</html>